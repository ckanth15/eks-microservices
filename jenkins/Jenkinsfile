pipeline {
    agent any
    
    environment {
        AWS_REGION = 'us-west-2'
        ECR_REGISTRY = '123456789012.dkr.ecr.us-west-2.amazonaws.com'
        EKS_CLUSTER_NAME = 'eks-microservices'
        DOCKER_IMAGE_TAG = "${env.BUILD_NUMBER}"
        GITHUB_REPO = 'your-username/eks-microservices'
        ARGOCD_SERVER = 'argocd.eks-microservices.com'
        ARGOCD_TOKEN = credentials('argocd-token')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                echo "✅ Code checkout completed"
            }
        }
        
        stage('Install Dependencies') {
            parallel {
                stage('Frontend Dependencies') {
                    steps {
                        dir('frontend') {
                            sh 'npm ci'
                        }
                    }
                }
                stage('Backend Dependencies') {
                    steps {
                        dir('backend/user-service') {
                            sh 'npm ci'
                        }
                        dir('backend/product-service') {
                            sh 'npm ci'
                        }
                        dir('backend/order-service') {
                            sh 'npm ci'
                        }
                    }
                }
            }
            post {
                always {
                    echo "✅ Dependencies installation completed"
                }
            }
        }
        
        stage('Code Quality') {
            parallel {
                stage('Frontend Linting') {
                    steps {
                        dir('frontend') {
                            sh 'npm run lint'
                        }
                    }
                }
                stage('Backend Linting') {
                    steps {
                        dir('backend/user-service') {
                            sh 'npm run lint'
                        }
                        dir('backend/product-service') {
                            sh 'npm run lint'
                        }
                        dir('backend/order-service') {
                            sh 'npm run lint'
                        }
                    }
                }
            }
            post {
                always {
                    echo "✅ Code quality checks completed"
                }
            }
        }
        
        stage('Testing') {
            parallel {
                stage('Frontend Tests') {
                    steps {
                        dir('frontend') {
                            sh 'npm test -- --coverage --watchAll=false'
                        }
                    }
                }
                stage('Backend Tests') {
                    steps {
                        dir('backend/user-service') {
                            sh 'npm test'
                        }
                        dir('backend/product-service') {
                            sh 'npm test'
                        }
                        dir('backend/order-service') {
                            sh 'npm test'
                        }
                    }
                }
            }
            post {
                always {
                    echo "✅ Testing completed"
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                script {
                    // Run Trivy vulnerability scanner
                    sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL node:18-alpine'
                    sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL postgres:15-alpine'
                    sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL nginx:alpine'
                }
            }
            post {
                always {
                    echo "✅ Security scanning completed"
                }
            }
        }
        
        stage('Build Docker Images') {
            parallel {
                stage('Build Frontend') {
                    steps {
                        script {
                            docker.build("${ECR_REGISTRY}/frontend:${DOCKER_IMAGE_TAG}")
                        }
                    }
                }
                stage('Build User Service') {
                    steps {
                        script {
                            docker.build("${ECR_REGISTRY}/user-service:${DOCKER_IMAGE_TAG}")
                        }
                    }
                }
                stage('Build Product Service') {
                    steps {
                        script {
                            docker.build("${ECR_REGISTRY}/product-service:${DOCKER_IMAGE_TAG}")
                        }
                    }
                }
                stage('Build Order Service') {
                    steps {
                        script {
                            docker.build("${ECR_REGISTRY}/order-service:${DOCKER_IMAGE_TAG}")
                        }
                    }
                }
            }
            post {
                always {
                    echo "✅ Docker image building completed"
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                script {
                    // Login to ECR
                    sh 'aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}'
                    
                    // Push images
                    sh 'docker push ${ECR_REGISTRY}/frontend:${DOCKER_IMAGE_TAG}'
                    sh 'docker push ${ECR_REGISTRY}/user-service:${DOCKER_IMAGE_TAG}'
                    sh 'docker push ${ECR_REG_REGISTRY}/product-service:${DOCKER_IMAGE_TAG}'
                    sh 'docker push ${ECR_REGISTRY}/order-service:${DOCKER_IMAGE_TAG}'
                    
                    // Tag as latest
                    sh 'docker tag ${ECR_REGISTRY}/frontend:${DOCKER_IMAGE_TAG} ${ECR_REGISTRY}/frontend:latest'
                    sh 'docker tag ${ECR_REGISTRY}/user-service:${DOCKER_IMAGE_TAG} ${ECR_REGISTRY}/user-service:latest'
                    sh 'docker tag ${ECR_REGISTRY}/product-service:${DOCKER_IMAGE_TAG} ${ECR_REGISTRY}/product-service:latest'
                    sh 'docker tag ${ECR_REGISTRY}/order-service:${DOCKER_IMAGE_TAG} ${ECR_REGISTRY}/order-service:latest'
                    
                    sh 'docker push ${ECR_REGISTRY}/frontend:latest'
                    sh 'docker push ${ECR_REGISTRY}/user-service:latest'
                    sh 'docker push ${ECR_REGISTRY}/product-service:latest'
                    sh 'docker push ${ECR_REGISTRY}/order-service:latest'
                }
            }
            post {
                always {
                    echo "✅ Docker images pushed to ECR"
                }
            }
        }
        
        stage('Update Kubernetes Manifests') {
            steps {
                script {
                    // Update image tags in Kubernetes manifests
                    sh '''
                        sed -i "s|image: .*/frontend:.*|image: ${ECR_REGISTRY}/frontend:${DOCKER_IMAGE_TAG}|g" k8s/frontend.yaml
                        sed -i "s|image: .*/user-service:.*|image: ${ECR_REGISTRY}/user-service:${DOCKER_IMAGE_TAG}|g" k8s/user-service.yaml
                        sed -i "s|image: .*/product-service:.*|image: ${ECR_REGISTRY}/product-service:${DOCKER_IMAGE_TAG}|g" k8s/product-service.yaml
                        sed -i "s|image: .*/order-service:.*|image: ${ECR_REGISTRY}/order-service:${DOCKER_IMAGE_TAG}|g" k8s/order-service.yaml
                    '''
                    
                    // Commit and push changes
                    sh '''
                        git config user.email "jenkins@eks-microservices.com"
                        git config user.name "Jenkins CI"
                        git add k8s/
                        git commit -m "Update image tags to ${DOCKER_IMAGE_TAG} [skip ci]"
                        git push origin HEAD:main
                    '''
                }
            }
            post {
                always {
                    echo "✅ Kubernetes manifests updated and pushed"
                }
            }
        }
        
        stage('Deploy to EKS') {
            steps {
                script {
                    // Update kubeconfig
                    sh 'aws eks update-kubeconfig --region ${AWS_REGION} --name ${EKS_CLUSTER_NAME}'
                    
                    // Apply namespace
                    sh 'kubectl apply -f k8s/namespace.yaml'
                    
                    // Apply database
                    sh 'kubectl apply -f k8s/postgresql.yaml'
                    
                    // Wait for database to be ready
                    sh 'kubectl wait --for=condition=ready pod -l app=postgres -n eks-microservices --timeout=300s'
                    
                    // Apply services
                    sh 'kubectl apply -f k8s/user-service.yaml'
                    sh 'kubectl apply -f k8s/product-service.yaml'
                    sh 'kubectl apply -f k8s/order-service.yaml'
                    sh 'kubectl apply -f k8s/frontend.yaml'
                    
                    // Wait for services to be ready
                    sh 'kubectl wait --for=condition=ready pod -l app=user-service -n eks-microservices --timeout=300s'
                    sh 'kubectl wait --for=condition=ready pod -l app=product-service -n eks-microservices --timeout=300s'
                    sh 'kubectl wait --for=condition=ready pod -l app=order-service -n eks-microservices --timeout=300s'
                    sh 'kubectl wait --for=condition=ready pod -l app=frontend -n eks-microservices --timeout=300s'
                }
            }
            post {
                always {
                    echo "✅ Deployment to EKS completed"
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    // Wait for services to be fully ready
                    sleep 30
                    
                    // Check service health
                    sh '''
                        kubectl get pods -n eks-microservices
                        kubectl get services -n eks-microservices
                        kubectl get ingress -n eks-microservices
                    '''
                    
                    // Test endpoints
                    sh '''
                        # Get service URLs
                        USER_SERVICE_URL=$(kubectl get service user-service -n eks-microservices -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        FRONTEND_URL=$(kubectl get service frontend -n eks-microservices -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        
                        # Test health endpoints
                        curl -f http://$USER_SERVICE_URL/health || exit 1
                        curl -f http://$FRONTEND_URL/ || exit 1
                    '''
                }
            }
            post {
                always {
                    echo "✅ Health checks completed"
                }
            }
        }
        
        stage('Notify ArgoCD') {
            steps {
                script {
                    // Trigger ArgoCD sync if needed
                    sh '''
                        curl -X POST \
                          -H "Authorization: Bearer ${ARGOCD_TOKEN}" \
                          -H "Content-Type: application/json" \
                          "https://${ARGOCD_SERVER}/api/v1/applications/eks-microservices/sync"
                    '''
                }
            }
            post {
                always {
                    echo "✅ ArgoCD notification sent"
                }
            }
        }
    }
    
    post {
        always {
            // Cleanup
            sh 'docker system prune -f'
            echo "🧹 Cleanup completed"
        }
        success {
            echo "🎉 Pipeline completed successfully!"
            // Send success notification
            emailext (
                subject: "Pipeline SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: "Pipeline completed successfully. Build: ${env.BUILD_URL}",
                recipientProviders: [[$class: 'DevelopersRecipientProvider']]
            )
        }
        failure {
            echo "❌ Pipeline failed!"
            // Send failure notification
            emailext (
                subject: "Pipeline FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: "Pipeline failed. Build: ${env.BUILD_URL}",
                recipientProviders: [[$class: 'DevelopersRecipientProvider']]
            )
        }
    }
}
